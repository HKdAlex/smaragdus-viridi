---
description: 
globs: 
alwaysApply: true
---
# Media Management System - Smaragdus Viridi

## File Upload with Watermarking

### Core Media Service
```typescript
// features/media/services/media-service.ts
import { Logger } from '@/shared/utils/logger'
import { S3Service } from '@/shared/services/s3-service'

export class MediaService {
  constructor(
    private s3Service: S3Service, 
    private logger: Logger
  ) {}

  async uploadGemstoneImages(
    gemstoneId: string,
    files: File[],
    serialNumber: string
  ): Promise<Result<MediaUploadResult[], MediaError>> {
    try {
      const results: MediaUploadResult[] = []

      for (const file of files) {
        // Validate file before processing
        const validation = validateImageFile(file)
        if (!validation.data) {
          throw new Error(validation.error.message)
        }

        // Add serial number watermark
        const watermarkedFile = await this.addSerialNumberWatermark(
          file,
          serialNumber
        )

        // Upload to S3
        const uploadResult = await this.s3Service.upload(
          `gemstones/${gemstoneId}/images/${sanitizeFileName(file.name)}`,
          watermarkedFile
        )

        // Save to database
        const { data: imageRecord, error } = await this.supabase
          .from('gemstone_images')
          .insert({
            gemstone_id: gemstoneId,
            image_url: uploadResult.url,
            image_order: results.length + 1,
            has_watermark: true,
          })
          .select()
          .single()

        if (error) throw error

        results.push({
          id: imageRecord.id,
          url: uploadResult.url,
          originalName: file.name,
          serialNumber,
        })

        this.logger.info('Gemstone image uploaded', {
          gemstoneId,
          imageId: imageRecord.id,
          fileName: file.name,
          serialNumber,
          fileSize: file.size,
        })
      }

      return { data: results }
    } catch (error) {
      this.logger.error('Media upload failed', error as Error, { gemstoneId })
      return {
        error: new MediaError('UPLOAD_FAILED', (error as Error).message),
      }
    }
  }

  private async addSerialNumberWatermark(
    file: File,
    serialNumber: string
  ): Promise<File> {
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')
      const img = new Image()

      img.onload = () => {
        // Set canvas dimensions to match image
        canvas.width = img.width
        canvas.height = img.height

        // Draw the original image
        ctx?.drawImage(img, 0, 0)

        if (ctx) {
          // Add watermark in bottom-right corner
          ctx.font = `${Math.max(16, img.width * 0.02)}px Arial`
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)'
          ctx.lineWidth = 1

          const text = serialNumber
          const textWidth = ctx.measureText(text).width
          const x = img.width - textWidth - 20
          const y = img.height - 20

          // Add background rectangle
          ctx.fillRect(x - 10, y - 25, textWidth + 20, 35)
          
          // Add text
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'
          ctx.fillText(text, x, y)
          ctx.strokeText(text, x, y)
        }

        // Convert canvas to blob
        canvas.toBlob(
          (blob) => {
            if (blob) {
              const watermarkedFile = new File([blob], file.name, {
                type: file.type,
                lastModified: Date.now(),
              })
              resolve(watermarkedFile)
            } else {
              reject(new Error('Failed to create watermarked image'))
            }
          },
          file.type,
          0.95 // Quality
        )
      }

      img.onerror = () => reject(new Error('Failed to load image'))
      img.src = URL.createObjectURL(file)
    })
  }

  async generateDownloadZip(
    gemstoneId: string
  ): Promise<Result<string, MediaError>> {
    try {
      const { data: images } = await this.supabase
        .from('gemstone_images')
        .select('image_url, image_order')
        .eq('gemstone_id', gemstoneId)
        .order('image_order')

      const { data: videos } = await this.supabase
        .from('gemstone_videos')
        .select('video_url, video_order')
        .eq('gemstone_id', gemstoneId)
        .order('video_order')

      const { data: gemstone } = await this.supabase
        .from('gemstones')
        .select('serial_number')
        .eq('id', gemstoneId)
        .single()

      if (!gemstone) throw new Error('Gemstone not found')

      // Create ZIP file with all media
      const zipUrl = await this.createMediaZip(
        [
          ...(images?.map((i) => i.image_url) || []),
          ...(videos?.map((v) => v.video_url) || []),
        ],
        gemstone.serial_number
      )

      this.logger.info('Media download zip created', { 
        gemstoneId, 
        zipUrl,
        serialNumber: gemstone.serial_number,
        fileCount: (images?.length || 0) + (videos?.length || 0)
      })

      return { data: zipUrl }
    } catch (error) {
      this.logger.error('ZIP creation failed', error as Error, { gemstoneId })
      return {
        error: new MediaError('ZIP_CREATION_FAILED', (error as Error).message),
      }
    }
  }

  private async createMediaZip(urls: string[], serialNumber: string): Promise<string> {
    // Implementation using JSZip or similar library
    // Download all files, add to ZIP with proper naming
    // Upload ZIP to temporary S3 location
    // Return signed URL with expiration
    return 'https://example.com/download-zip-url'
  }

  async deleteGemstoneMedia(gemstoneId: string): Promise<Result<void, MediaError>> {
    try {
      // Get all media URLs to delete from S3
      const { data: images } = await this.supabase
        .from('gemstone_images')
        .select('image_url')
        .eq('gemstone_id', gemstoneId)

      const { data: videos } = await this.supabase
        .from('gemstone_videos')
        .select('video_url')
        .eq('gemstone_id', gemstoneId)

      // Delete from S3
      const allUrls = [
        ...(images?.map(i => i.image_url) || []),
        ...(videos?.map(v => v.video_url) || [])
      ]

      for (const url of allUrls) {
        await this.s3Service.deleteByUrl(url)
      }

      // Delete database records (cascade will handle this)
      const { error } = await this.supabase
        .from('gemstones')
        .delete()
        .eq('id', gemstoneId)

      if (error) throw error

      this.logger.info('Gemstone media deleted', { 
        gemstoneId,
        deletedCount: allUrls.length 
      })

      return { data: undefined }
    } catch (error) {
      this.logger.error('Media deletion failed', error as Error, { gemstoneId })
      return {
        error: new MediaError('DELETION_FAILED', (error as Error).message)
      }
    }
  }
}
```

## File Upload Security

### File Validators
```typescript
// features/media/utils/file-validators.ts
const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp'] as const
const ALLOWED_VIDEO_TYPES = ['video/mp4', 'video/webm'] as const
const MAX_IMAGE_SIZE = 50 * 1024 * 1024 // 50MB
const MAX_VIDEO_SIZE = 500 * 1024 * 1024 // 500MB

export class ValidationError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'ValidationError'
  }
}

export function validateImageFile(file: File): Result<File, ValidationError> {
  // Check file type
  if (!ALLOWED_IMAGE_TYPES.includes(file.type as any)) {
    return {
      error: new ValidationError(
        'Invalid file type. Only JPEG, PNG, and WebP are allowed.'
      ),
    }
  }

  // Check file size
  if (file.size > MAX_IMAGE_SIZE) {
    return {
      error: new ValidationError('Image too large. Maximum size is 50MB.'),
    }
  }

  // Check file name for malicious content
  if (!/^[a-zA-Z0-9._-]+$/.test(file.name)) {
    return {
      error: new ValidationError(
        'Invalid file name. Only alphanumeric characters, dots, underscores, and hyphens are allowed.'
      ),
    }
  }

  // Check for minimum dimensions (avoid tiny images)
  return new Promise((resolve) => {
    const img = new Image()
    img.onload = () => {
      if (img.width < 100 || img.height < 100) {
        resolve({
          error: new ValidationError('Image too small. Minimum size is 100x100 pixels.')
        })
      } else {
        resolve({ data: file })
      }
    }
    img.onerror = () => {
      resolve({
        error: new ValidationError('Invalid image file.')
      })
    }
    img.src = URL.createObjectURL(file)
  })
}

export function validateVideoFile(file: File): Result<File, ValidationError> {
  // Check file type
  if (!ALLOWED_VIDEO_TYPES.includes(file.type as any)) {
    return {
      error: new ValidationError(
        'Invalid file type. Only MP4 and WebM are allowed.'
      ),
    }
  }

  // Check file size
  if (file.size > MAX_VIDEO_SIZE) {
    return {
      error: new ValidationError('Video too large. Maximum size is 500MB.'),
    }
  }

  return { data: file }
}

export function sanitizeFileName(fileName: string): string {
  return fileName
    .replace(/[^a-zA-Z0-9._-]/g, '_')
    .replace(/_{2,}/g, '_')
    .toLowerCase()
}
```

## Media Upload Components

### Drag & Drop Upload
```typescript
// features/media/components/media-upload.tsx
"use client"

import { useState, useCallback } from 'react'
import { useDropzone } from 'react-dropzone'
import { MediaService } from '../services/media-service'
import { validateImageFile, validateVideoFile } from '../utils/file-validators'

interface MediaUploadProps {
  gemstoneId: string
  serialNumber: string
  onUploadComplete: (results: MediaUploadResult[]) => void
  onUploadError: (error: string) => void
}

export function MediaUpload({
  gemstoneId,
  serialNumber,
  onUploadComplete,
  onUploadError,
}: MediaUploadProps) {
  const [isUploading, setIsUploading] = useState(false)
  const [uploadProgress, setUploadProgress] = useState(0)

  const mediaService = new MediaService()

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    setIsUploading(true)
    setUploadProgress(0)

    try {
      // Validate all files first
      const validationResults = await Promise.all(
        acceptedFiles.map(async (file) => {
          if (file.type.startsWith('image/')) {
            return validateImageFile(file)
          } else if (file.type.startsWith('video/')) {
            return validateVideoFile(file)
          } else {
            return { 
              error: new ValidationError('Unsupported file type') 
            }
          }
        })
      )

      // Check for validation errors
      const errors = validationResults
        .filter(result => !result.data)
        .map(result => result.error!.message)

      if (errors.length > 0) {
        onUploadError(errors.join(', '))
        return
      }

      // Upload images
      const imageFiles = acceptedFiles.filter(f => f.type.startsWith('image/'))
      const videoFiles = acceptedFiles.filter(f => f.type.startsWith('video/'))

      let allResults: MediaUploadResult[] = []

      if (imageFiles.length > 0) {
        const imageResult = await mediaService.uploadGemstoneImages(
          gemstoneId,
          imageFiles,
          serialNumber
        )
        
        if (imageResult.data) {
          allResults = [...allResults, ...imageResult.data]
        } else {
          throw new Error(imageResult.error?.message)
        }
      }

      if (videoFiles.length > 0) {
        const videoResult = await mediaService.uploadGemstoneVideos(
          gemstoneId,
          videoFiles
        )
        
        if (videoResult.data) {
          allResults = [...allResults, ...videoResult.data]
        } else {
          throw new Error(videoResult.error?.message)
        }
      }

      onUploadComplete(allResults)
    } catch (error) {
      onUploadError((error as Error).message)
    } finally {
      setIsUploading(false)
      setUploadProgress(0)
    }
  }, [gemstoneId, serialNumber, onUploadComplete, onUploadError, mediaService])

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png', '.webp'],
      'video/*': ['.mp4', '.webm']
    },
    maxSize: 500 * 1024 * 1024, // 500MB
    disabled: isUploading
  })

  return (
    <div className="w-full">
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors ${
          isDragActive
            ? 'border-blue-400 bg-blue-50'
            : 'border-gray-300 hover:border-gray-400'
        } ${isUploading ? 'opacity-50 cursor-not-allowed' : ''}`}
      >
        <input {...getInputProps()} />
        
        {isUploading ? (
          <div className="space-y-4">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto" />
            <p className="text-sm text-gray-600">Uploading files...</p>
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div 
                className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                style={{ width: `${uploadProgress}%` }}
              />
            </div>
          </div>
        ) : (
          <div className="space-y-2">
            <div className="text-4xl text-gray-400">ðŸ“·</div>
            <p className="text-lg font-medium text-gray-900">
              {isDragActive ? 'Drop files here' : 'Upload gemstone media'}
            </p>
            <p className="text-sm text-gray-600">
              Drag & drop images and videos, or click to select
            </p>
            <p className="text-xs text-gray-500">
              Supports: JPEG, PNG, WebP (up to 50MB), MP4, WebM (up to 500MB)
            </p>
          </div>
        )}
      </div>
    </div>
  )
}
```

## Media Gallery Component
```typescript
// features/media/components/media-gallery.tsx
"use client"

import { useState } from 'react'
import Image from 'next/image'
import { GemstoneImage, GemstoneVideo } from '../types/media.types'

interface MediaGalleryProps {
  images: GemstoneImage[]
  videos: GemstoneVideo[]
  serialNumber: string
  onDownloadAll?: () => void
}

export function MediaGallery({
  images,
  videos,
  serialNumber,
  onDownloadAll,
}: MediaGalleryProps) {
  const [selectedMedia, setSelectedMedia] = useState<string | null>(null)
  const [currentIndex, setCurrentIndex] = useState(0)

  const allMedia = [
    ...images.map(img => ({ ...img, type: 'image' })),
    ...videos.map(vid => ({ ...vid, type: 'video' }))
  ].sort((a, b) => (a.image_order || a.video_order || 0) - (b.image_order || b.video_order || 0))

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">
          Media Gallery ({allMedia.length} files)
        </h3>
        {onDownloadAll && allMedia.length > 0 && (
          <button
            onClick={onDownloadAll}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            Download All
          </button>
        )}
      </div>

      {/* Gallery Grid */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
        {allMedia.map((item, index) => (
          <div
            key={item.id}
            className="relative aspect-square rounded-lg overflow-hidden cursor-pointer hover:opacity-90 transition-opacity"
            onClick={() => {
              setSelectedMedia(item.id)
              setCurrentIndex(index)
            }}
          >
            {item.type === 'image' ? (
              <Image
                src={item.image_url || item.video_url}
                alt={`Gemstone ${serialNumber}`}
                fill
                className="object-cover"
                sizes="(max-width: 768px) 50vw, (max-width: 1200px) 33vw, 25vw"
              />
            ) : (
              <div className="relative w-full h-full bg-gray-900 flex items-center justify-center">
                <video
                  src={item.video_url}
                  className="w-full h-full object-cover"
                  muted
                />
                <div className="absolute inset-0 flex items-center justify-center">
                  <div className="w-12 h-12 bg-white bg-opacity-90 rounded-full flex items-center justify-center">
                    <svg className="w-6 h-6 text-gray-800" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M8 5v10l8-5-8-5z"/>
                    </svg>
                  </div>
                </div>
              </div>
            )}

            {/* Serial number overlay */}
            <div className="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white text-xs px-2 py-1 rounded">
              {serialNumber}
            </div>
          </div>
        ))}
      </div>

      {/* Lightbox Modal */}
      {selectedMedia && (
        <MediaLightbox
          media={allMedia}
          currentIndex={currentIndex}
          onClose={() => setSelectedMedia(null)}
          onNavigate={setCurrentIndex}
        />
      )}
    </div>
  )
}
```

## Media Types
```typescript
// features/media/types/media.types.ts
export interface GemstoneImage {
  id: string
  gemstone_id: string
  image_url: string
  image_order: number
  is_primary: boolean
  has_watermark: boolean
  created_at: string
}

export interface GemstoneVideo {
  id: string
  gemstone_id: string
  video_url: string
  video_order: number
  duration_seconds?: number
  thumbnail_url?: string
  created_at: string
}

export interface MediaUploadResult {
  id: string
  url: string
  originalName: string
  serialNumber: string
}

export class MediaError extends Error {
  constructor(
    public code: 'UPLOAD_FAILED' | 'VALIDATION_FAILED' | 'ZIP_CREATION_FAILED' | 'DELETION_FAILED',
    message: string
  ) {
    super(message)
    this.name = 'MediaError'
  }
}

export type Result<T, E = Error> = 
  | { data: T; error?: never }
  | { data?: never; error: E }
```

## Best Practices

### Security
- Always validate file types and sizes on both client and server
- Sanitize file names to prevent path traversal attacks
- Add watermarks to protect intellectual property
- Use signed URLs with expiration for downloads
- Implement rate limiting for uploads

### Performance
- Optimize images before upload (resize, compress)
- Use progressive JPEG for better loading experience
- Implement lazy loading for gallery views
- Cache thumbnails for faster gallery rendering
- Use CDN for media delivery

### User Experience
- Show upload progress with visual feedback
- Support drag & drop for easy file selection
- Provide preview before upload confirmation
- Allow batch operations (upload multiple, download all)
- Display file information (size, type, dimensions)

### Storage Management
- Organize files in logical S3 folder structure
- Implement automatic cleanup of orphaned files
- Use S3 lifecycle policies for cost optimization
- Monitor storage usage and costs
- Backup media files regularly
